package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/goccy/go-yaml"
)

type OpenAPISpec struct {
	Paths map[string]PathItem `yaml:"paths"`
}

type PathItem struct {
	Get    *Operation `yaml:"get,omitempty"`
	Post   *Operation `yaml:"post,omitempty"`
	Put    *Operation `yaml:"put,omitempty"`
	Delete *Operation `yaml:"delete,omitempty"`
	Patch  *Operation `yaml:"patch,omitempty"`
}

type Operation struct {
	OperationID string                `yaml:"operationId"`
	Security    []map[string][]string `yaml:"security,omitempty"`
}

func main() {
	var specPath, outputPath string

	if len(os.Args) > 2 {
		specPath = os.Args[1]
		outputPath = os.Args[2]
	} else {
		specPath = "../contracts/openapi.bundled.yaml"
		outputPath = "internal/generated/rbac.go"
	}

	data, err := os.ReadFile(specPath)
	if err != nil {
		log.Fatalf("Failed to read OpenAPI spec: %v", err)
	}

	var spec OpenAPISpec
	if err := yaml.Unmarshal(data, &spec); err != nil {
		log.Fatalf("Failed to parse OpenAPI spec: %v", err)
	}

	code := generateRBACCode(spec)

	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	if err := os.WriteFile(outputPath, []byte(code), 0644); err != nil {
		log.Fatalf("Failed to write output: %v", err)
	}

	fmt.Printf("âœ… Generated RBAC map: %s\n", outputPath)
	fmt.Printf("ðŸ“Š Total routes: %d\n", len(spec.Paths))
}

func generateRBACCode(spec OpenAPISpec) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by oapi-codegen (generate-rbac) - DO NOT EDIT.\n")
	sb.WriteString("// Source: contracts/openapi.bundled.yaml\n\n")
	sb.WriteString("package generated\n\n")

	sb.WriteString("// RouteSecurityInfo contains security information for a route\n")
	sb.WriteString("type RouteSecurityInfo struct {\n")
	sb.WriteString("\tIsPublic       bool\n")
	sb.WriteString("\tRequiredScopes []string\n")
	sb.WriteString("}\n\n")

	sb.WriteString("// RouteSecurity defines security requirements for each route\n")
	sb.WriteString("// Automatically generated from OpenAPI security specifications\n")
	sb.WriteString("//\n")
	sb.WriteString("// Rules:\n")
	sb.WriteString("//   No security field          = PUBLIC (IsPublic: true)\n")
	sb.WriteString("//   security: - BearerAuth: [] = ANY authenticated user (IsPublic: false, RequiredScopes: [])\n")
	sb.WriteString("//   security: - BearerAuth: [admin] = ADMIN only (IsPublic: false, RequiredScopes: [admin])\n")
	sb.WriteString("var RouteSecurity = map[string]map[string]RouteSecurityInfo{\n")

	paths := make([]string, 0, len(spec.Paths))
	for path := range spec.Paths {
		paths = append(paths, path)
	}
	sort.Strings(paths)

	for _, path := range paths {
		item := spec.Paths[path]
		fullPath := "/api/v1" + path

		methods := collectMethods(item)
		if len(methods) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("\t\"%s\": {\n", fullPath))

		methodNames := make([]string, 0, len(methods))
		for method := range methods {
			methodNames = append(methodNames, method)
		}
		sort.Strings(methodNames)

		for _, method := range methodNames {
			secInfo := methods[method]
			sb.WriteString(fmt.Sprintf("\t\t\"%s\": {IsPublic: %v, RequiredScopes: %s},\n",
				method, secInfo.IsPublic, formatScopes(secInfo.RequiredScopes)))
		}

		sb.WriteString("\t},\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

type SecurityInfo struct {
	IsPublic       bool
	RequiredScopes []string
}

func collectMethods(item PathItem) map[string]SecurityInfo {
	methods := make(map[string]SecurityInfo)

	if item.Get != nil {
		methods["GET"] = extractSecurityInfo(item.Get.Security)
	}
	if item.Post != nil {
		methods["POST"] = extractSecurityInfo(item.Post.Security)
	}
	if item.Put != nil {
		methods["PUT"] = extractSecurityInfo(item.Put.Security)
	}
	if item.Delete != nil {
		methods["DELETE"] = extractSecurityInfo(item.Delete.Security)
	}
	if item.Patch != nil {
		methods["PATCH"] = extractSecurityInfo(item.Patch.Security)
	}

	return methods
}

func extractSecurityInfo(security []map[string][]string) SecurityInfo {
	// No security field = PUBLIC endpoint
	if len(security) == 0 {
		return SecurityInfo{
			IsPublic:       true,
			RequiredScopes: nil,
		}
	}

	// Get first security requirement
	firstReq := security[0]

	// Empty map = PUBLIC endpoint (shouldn't happen, but handle it)
	if len(firstReq) == 0 {
		return SecurityInfo{
			IsPublic:       true,
			RequiredScopes: nil,
		}
	}

	// Get scopes from BearerAuth
	if scopes, ok := firstReq["BearerAuth"]; ok {
		// BearerAuth: [] = any authenticated user
		// BearerAuth: [admin] = admin only
		// BearerAuth: [user, admin] = user or admin
		return SecurityInfo{
			IsPublic:       false,
			RequiredScopes: scopes,
		}
	}

	// Has security but no BearerAuth = treat as authenticated
	return SecurityInfo{
		IsPublic:       false,
		RequiredScopes: []string{},
	}
}

func formatScopes(scopes []string) string {
	if scopes == nil {
		return "nil"
	}

	if len(scopes) == 0 {
		return "[]string{}"
	}

	quoted := make([]string, len(scopes))
	for i, s := range scopes {
		quoted[i] = fmt.Sprintf("\"%s\"", s)
	}

	return fmt.Sprintf("[]string{%s}", strings.Join(quoted, ", "))
}
